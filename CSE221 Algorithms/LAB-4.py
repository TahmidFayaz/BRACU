# -*- coding: utf-8 -*-
"""221-4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/172av7nvTV1ZK2lFwBBY6Ou7ASWqMfYPG
"""

#Task 1 A

import numpy as np

input_file = open("input1a.txt", "r")
output_file = open("output1a.txt", "w")

vertices, edges = input_file.readline().strip().split()

matrix = np.zeros((int(vertices) + 1, int(vertices) + 1), dtype = int)

for i in range(int(edges)):
  row, col, weight = input_file.readline().strip().split()
  matrix[int(row)][int(col)] = int(weight)

show = ""
for row in range(int(vertices) + 1):
  for col in range(int(vertices) + 1):
    show += f"{matrix[row][col]} "
  show += f"\n"

output_file.write(show)

input_file.close()
output_file.close()

#Task 1 B

import numpy as np

input_file = open("input1b.txt", "r")
output_file = open("output1b.txt", "w")

vertices, edges = input_file.readline().strip().split()

tab = {}
for i in range(int(vertices) + 1):
  tab[i] = []

for i in range(int(edges)):
  edges = input_file.readline().strip().split()
  tab[int(edges[0])].append((int(edges[1]),int(edges[2])))

show = ""
for i in tab:
  show += f"{i} : "
  if tab[i] != []:
    for x in range(len(tab[i])):
      show += f"{tab[i][x]} "
  show += "\n"

output_file.write(show)

input_file.close()
output_file.close()

#Task 2

def enqueue(queue, vertex):
  queue.append(vertex)

def dequeue(queue):
  return queue.pop(0)

input_file = open("input2.txt", "r")
output_file = open("output2.txt", "w")

vertices, edges = input_file.readline().strip().split()

tab = {}
for i in range(int(vertices) + 1):
  tab[i] = []

for i in range(int(edges)):
  paths = input_file.readline().strip().split()
  tab[int(paths[0])].append(int(paths[1]))
  tab[int(paths[1])].append(int(paths[0]))

def bfs(graph, start):
  tab2 = {}
  for i in range(int(vertices) + 1):
    tab2[i] = 0

  queue = []
  tab2[start] += 1
  enqueue(queue, start)

  show = ""
  while queue:
    popped = dequeue(queue)
    show += f"{popped} "
    for adjacent in graph[popped]:
      if tab2[adjacent] == 0:
        tab2[adjacent] += 1
        enqueue(queue, adjacent)
  return show

output_file.write(bfs(tab, 1))

input_file.close()
output_file.close()

#Task 3

input_file = open("input3.txt", "r")
output_file = open("output3.txt", "w")

vertices, edges = input_file.readline().strip().split()

tab1 = {}
for i in range(int(vertices) + 1):
  tab1[i] = []

for i in range(int(edges)):
  paths = input_file.readline().strip().split()
  tab1[int(paths[0])].append(int(paths[1]))
  tab1[int(paths[1])].append(int(paths[0]))

tab2 = {}
for i in range(int(vertices) + 1):
  tab2[i] = 0

def dfs(graph, start):
  show = ""
  tab2[start] += 1
  show += f"{start} "

  for adjacent in graph[start]:
    if tab2[adjacent] == 0:
      show += dfs(graph, adjacent)

  return show

output_file.write(dfs(tab1, 1))

input_file.close()
output_file.close()

#Task 4

input_file = open("input4.txt", "r")
output_file = open("output4.txt", "w")

vertices, edges = input_file.readline().strip().split()

tab1 = {}
for i in range(int(vertices) + 1):
  tab1[i] = []

for i in range(int(edges)):
  paths = input_file.readline().strip().split()
  tab1[int(paths[0])].append(int(paths[1]))

tab2 = {}
for i in range(int(vertices) + 1):
  tab2[i] = 0

def check_cycle(graph, start):
  cycle = "NO"
  tab2[start] += 1

  for adjacent in graph[start]:
    if tab2[adjacent] == 0:
      cycle = check_cycle(graph, adjacent)
      tab2[adjacent] += 1
    elif tab2[adjacent] == 1:
      cycle = "YES"
      return cycle
  return cycle

output_file.write(str(check_cycle(tab1, 1)))

input_file.close()
output_file.close()

#Task 5

def enqueue(queue, vertex):
  queue.append(vertex)

def dequeue(queue):
  return queue.pop(0)

input_file = open("input5.txt", "r")
output_file = open("output5.txt", "w")

vertices, edges, end = input_file.readline().strip().split()

tab1 = {}
for i in range(int(vertices) + 1):
  tab1[i] = []

for i in range(int(edges)):
  paths = input_file.readline().strip().split()
  tab1[int(paths[0])].append(int(paths[1]))
  tab1[int(paths[1])].append(int(paths[0]))

tab2 = {}
parent = {}
time = {}
for i in range(int(vertices) + 1):
  tab2[i] = 0
  parent[i] = None
  time[i] = float("inf")

def shortest_path(graph, start, end):
  queue = []
  tab2[start] += 1
  parent[start] = None
  time[start] = 0
  enqueue(queue, start)

  while queue:
    popped = dequeue(queue)
    for adjacent in graph[popped]:
      if tab2[adjacent] == 0:
        tab2[adjacent] += 1
        time[adjacent] = time[popped] + 1
        parent[adjacent] = popped
        enqueue(queue, adjacent)
      if adjacent == end:
        return

shortest_path(tab1, 1, int(end))
output_file.write(f"Time: {time[int(end)]}\nShortest Path: ")
path = [end]

while parent[int(end)]:
  path.append(parent[int(end)])
  end = parent[int(end)]
for i in path[-1::-1]:
  output_file.write(f"{i} ")

input_file.close()
output_file.close()

#task6
#(Eta submit kori nai, cause ei code ta bhoyongkor advanced compared to uporer gula)
#(Eta change kora lagbe but time chilo na, so do at your own risk.)

infile = open("input6_2.txt", "r")
outfile= open("output6_2.txt", "w")

R, H = list(map(int, infile.readline().strip().split()))
grid = [list(infile.readline().strip()) for i in range(R)]

def dfs(grid, visited, r, c):
    if r < 0 or r >= len(grid) or c < 0 or c >= len(grid[0]) or visited[r][c] or grid[r][c] == '#':
        return 0

    visited[r][c] = True
    d = 0

    if grid[r][c] == 'D':
        d += 1

    d += dfs(grid, visited, r + 1, c)
    d += dfs(grid, visited, r - 1, c)
    d += dfs(grid, visited, r, c + 1)
    d += dfs(grid, visited, r, c - 1)

    return d

max_d=0
visited = [[False] * H for i in range(R)]

def maximum(a,b):
    if a>b:
        return a
    else:
        return b

for i in range(R):
    for j in range(H):
        if grid[i][j] == '.':
            d = dfs(grid, visited, i, j)
            max_d = maximum(max_d, d)

outfile.write(str(max_d))
infile.close()
outfile.close()