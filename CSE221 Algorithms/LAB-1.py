# -*- coding: utf-8 -*-
"""221-1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Wkos1Sp8hH4wKRYZXXWPIZeW5SpQrazG
"""

#Task 1 a

input_file = open("input1a.txt" , "r")
output_file = open("output1a.txt" , "w")

exp = int(input_file.readline().strip())

for i in range(exp):
  num = int(input_file.readline().strip())
  if num % 2 == 0:
    output_file.write(f"{num} is an Even number.\n")
  else:
    output_file.write(f"{num} is an Odd number.\n")

input_file.close()
output_file.close()

#Task 1 b

input_file = open("input1b.txt" , "r")
output_file = open("output1b.txt" , "w")

exp = int(input_file.readline().strip())

for i in range(exp):
  num = input_file.readline().strip().split(" ")
  if num[2] == "+" :
    result = int(num[1]) + int(num[3])
  elif num[2] == "-" :
    result = int(num[1]) - int(num[3])
  elif num[2] == "*" :
    result = int(num[1]) * int(num[3])
  elif num[2] == "/" :
    result = int(num[1]) / int(num[3])
  output_file.write(f"The result of {num[1]} {num[2]} {num[3]} is {result}\n")

input_file.close()
output_file.close()

#Task 2

input_file = open("input2.txt" , "r")
output_file = open("output2.txt" , "w")

exp = int(input_file.readline().strip())
arr= input_file.readline().strip().split(" ")

for i in range(exp):
  arr[i] = int(arr[i])

def bubbleSort(arr):
  for i in range(len(arr)-1):
    sort_yes = True
    for j in range(len(arr)-i-1):
      if arr[j] > arr[j+1]:
        arr[j], arr[j+1] = arr[j+1], arr[j]
        sort_yes = False

    if sort_yes:
      break

  return arr

arr = bubbleSort(arr)
for i in arr:
  output_file.write(f"{i} ")

input_file.close()
output_file.close()

# Explanaton:
# A variable named sort_yes is taken in the function bubbleSort and declared to be true.
# After one complete iteration of j in the nested loop for any value of i, if all elements are sorted, it is changed to False.
# When the array is found sorted, the loop breaks. So, in best case scenario, when the array is founded after 1 iteration of i and n number of iterations for j,
# the program ends, and the time complexity is found to be O(n).

#Task 3

input_file = open("input3.txt" , "r")
output_file = open("output3.txt" , "w")

exp = int(input_file.readline().strip())
arr_A= input_file.readline().strip().split(" ")
arr_B= input_file.readline().strip().split(" ")

for i in range(exp):
  arr_A[i] = [int(arr_A[i]), int(arr_B[i])]

for i in range(len(arr_A)):
  point = i
  for j in range(i + 1, len(arr_A)):
    if arr_A[j][1] > arr_A[point][1]:
      point = j
    elif arr_A[j][1] == arr_A[point][1]:
      if arr_A[j][0] < arr_A[point][0]:
        point = j

  arr_A[i], arr_A[point] = arr_A[point], arr_A[i]

for i in range(exp):
  output_file.write(f"ID: {arr_A[i][0]} Mark: {arr_A[i][1]}\n")

input_file.close()
output_file.close()

# Explanation:
# For minimum number of swapping, selection sort algorithm has been used. A temporary "point" value has been taken to find the max.
# If a maximum is found, it is swapped; and in case of same marks with different IDs, an elif function is used to swap them accordingly.
# In order to avoid the need for another loop, we keep a record of the ID along with checking the marks to make sure the elements in the array are sorted according to IDs if equal marks appear.

#Task 4

input_file = open("input4.txt" , "r")
output_file = open("output4.txt" , "w")

exp = int(input_file.readline().strip())
Jum_Rail = []
for i in range(exp):
  Jum_Rail.append(input_file.readline().strip().split(" "))
  Jum_Rail[i] = [Jum_Rail[i][0], Jum_Rail[i][4], Jum_Rail[i][6]]

for i in range(exp):
  point = i
  for j in range(i + 1, exp):
    if Jum_Rail[j][0] < Jum_Rail[point][0]:
      point = j
    elif Jum_Rail[j][0] == Jum_Rail[point][0]:
      if Jum_Rail[j][2] > Jum_Rail[point][2]:
        point = j
  Jum_Rail[i], Jum_Rail[point] = Jum_Rail[point], Jum_Rail[i]

for i in range(exp):
  output_file.write(f"{Jum_Rail[i][0]} will departure for {Jum_Rail[i][1]} at {Jum_Rail[i][2]}\n")

input_file.close()
output_file.close()

# Explanation:
# For minimum number of swapping, selection sort algorithm has been used. A temporary "point" value has been taken to find the lexicographically smaller name
# of train is found from the array. If a minimum is found, it is swapped; and in case of same train names with different departure times, an elif function is used to swap them accordingly.
# In case of trains with same name and departure time, while sorting, the train that appears first in the input file remains first.