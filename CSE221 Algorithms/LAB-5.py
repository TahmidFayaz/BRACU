# -*- coding: utf-8 -*-
"""221-5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1i6puVbC4OhTmNGfNIkCkD5z1KRv4FpCM
"""

#Task 1A

input_file = open("input1A_2.txt" , "r")
output_file = open("output1A_2.txt" , "w")

vertex, edges = map(int, input_file.readline().split())

dic = {i:[] for i in range(vertex + 1)}
for i in range(edges):
  x, y = map(int, input_file.readline().split())
  dic[x].append(y)

def DFS(Graph, u, time, visited, start_time, finish_time, stack):
  start_time[u] = time
  time += 1
  visited[u] = True
  stack[u] = True
  cycle_detected = False

  for v in Graph[u]:
    if not visited[v]:
      time, finish_time, cycle_detected = DFS(Graph, v, time, visited, start_time, finish_time, stack)
      if cycle_detected:
        break
    elif stack[v]:
      cycle_detected = True
      break

  finish_time[u] = time
  time += 1
  stack[u] = False
  return time, finish_time, cycle_detected

def isCycle(Graph):
  vertice_count = len(Graph)
  visited = [False] * vertice_count
  start_time = [False] * vertice_count
  finish_time = {i:[] for i in range(vertice_count)}
  stack = [False] * vertice_count
  time = 1
  cycle_detected = False
  for u in Graph:
    if not visited[u]:
      time, finish_time, cycle_detected = DFS(Graph, u, time, visited, start_time, finish_time, stack)
      if cycle_detected:
        break
  return finish_time, cycle_detected

end_times, cycle = isCycle(dic)
if not cycle:
  result = [key for key, value in sorted(end_times.items(), key = lambda item: item[1], reverse = True)]
  result.remove(0)
  output_file.write(" ".join(list(map(str, result))))
else:
  output_file.write("IMPOSSIBLE")

input_file.close()
output_file.close()

#Task 1B

input_file = open("input1B_3.txt" , "r")
output_file = open("output1B_3.txt" , "w")

vertex, edges = map(int, input_file.readline().split())

ind = [0]*(vertex + 1)
dic = {i:[] for i in range(1, vertex + 1)}
for i in range(edges):
  x, y = map(int, input_file.readline().split())
  dic[x].append(y)
  ind[y] = ind[y] + 1

def TopsortBFS(Graph, ind):
  count = 0
  queue1 = []
  final = []
  for i in Graph:
    if ind[i] == 0:
      queue1.append(i)
  while queue1:
    j = queue1.pop()
    count += 1
    final.append(j)
    for i in Graph[j]:
      ind[i] = ind[i] - 1
      if ind[i] == 0:
        queue1.append(i)
  if count != len(Graph):
    return ["IMPOSSIBLE"]
  else:
    return final

result = TopsortBFS(dic,ind)
output_file.write(" ".join(list(map(str, result))))

input_file.close()
output_file.close()

#Task 2

input_file = open("input2_3.txt" , "r")
output_file = open("output2_3.txt" , "w")

vertex, edges = map(int, input_file.readline().split())

ind = [0]*(vertex + 1)
dic = {i:[] for i in range(1, vertex + 1)}
for i in range(edges):
  x, y = map(int, input_file.readline().split())
  dic[x].append(y)
  ind[y] = ind[y] + 1

def LexBFS(Graph, ind):
  count = 0
  queue1 = []
  final = []
  for i in Graph:
    if ind[i] == 0:
      queue1.append(i)
  while queue1:
    j = min(queue1)
    queue1.remove(j)
    count += 1
    final.append(j)
    for i in Graph[j]:
      ind[i] = ind[i] - 1
      if ind[i] == 0:
        queue1.append(i)
  if count != len(Graph):
    return ["IMPOSSIBLE"]
  else:
    return final

result = LexBFS(dic,ind)
output_file.write(" ".join(list(map(str, result))))

input_file.close()
output_file.close()

#Task3

input_file = open("input3_2.txt" , "r")
output_file = open("output3_2.txt" , "w")

vertex, edges = map(int, input_file.readline().split())

dic = {i:[] for i in range(vertex + 1)}
for i in range(edges):
  x, y = map(int, input_file.readline().split())
  dic[x].append(y)

def DFS(Graph, v, visited, stack):
  visited[v] = True
  for i in Graph[v]:
    if not visited[i]:
      DFS(Graph, i, visited, stack)
  stack.append(v)

def transpose(Graph):
  transp_Graph = {i:[] for i in range(len(Graph))}
  for i in Graph:
    for j in Graph[i]:
      transp_Graph[j].append(i)
  return transp_Graph

def short_comp_DFS(Graph, v, visited, short_comp):
  visited[v] = True
  short_comp.append(v)
  for i in Graph[v]:
    if not visited[i]:
      short_comp_DFS(Graph, i, visited, short_comp)

def short_comp(Graph):
  stack = []
  visited = [False] * len(Graph)
  for i in range(len(Graph)):
    if not visited[i]:
      DFS(Graph, i, visited, stack)

  transposed = transpose(Graph)
  visited = [False] * len(Graph)
  short_components = []

  while stack:
    v = stack.pop()
    if v!= 0:
      if not visited[v]:
        short_comp = []
        short_comp_DFS(transposed, v, visited, short_comp)
        short_components.append(short_comp)
  return short_components

short_comp = short_comp(dic)
for i in range(len(short_comp)):
  output_file.write(" ".join(list(map(str, short_comp[i]))))
  if i < len(short_comp) - 1:
    output_file.write("\n")

input_file.close()
output_file.close()