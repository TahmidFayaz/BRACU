# -*- coding: utf-8 -*-
"""221-6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15sqqSa39Vf90luhat4O6FhvFpeMFZafU
"""

#Task 1
import heapq as h

input_file = open("input1_2.txt" , "r")
output_file = open("output1_2.txt" , "w")

nodes, edges = map(int, input_file.readline().strip().split())
graph = {}

for i in range(1, nodes + 1):
  graph[i] = []

for i in range(edges):
  u, v, weights = map(int, input_file.readline().strip().split())
  graph[u].append((v, weights))

def dijkstra(graph, source):
  n = len(graph)
  dists = {}
  for i in range(1, n + 1):
    dists[i] = - 1
  dists[source] = 0
  pq = [(0, source)]
  while pq:
    dist_u, u  = h.heappop(pq)
    for v, weights in graph[u]:
      if dists[v] == -1 or dist_u + weights < dists[v]:
        dists[v] = dist_u + weights
        h.heappush(pq, (dists[v], v))
  return dists

source = int(input_file.readline().strip())
s_path = dijkstra(graph, source)

for i in s_path:
  output_file.write(f'{s_path[i]} ')

input_file.close()
output_file.close()

#Task 2
import heapq as h

input_file = open("input2_3.txt" , "r")
output_file = open("output2_3.txt" , "w")

nodes, edges = map(int, input_file.readline().strip().split())
graph = {}

for i in range(1, nodes + 1):
  graph[i] = []

for i in range(edges):
  u, v, weight = map(int, input_file.readline().strip().split())
  graph[u].append((v, weight))

def dijkstra(graph, source):
  n = len(graph)
  dist = {}
  for i in range(1, n + 1):
    dist[i] = -1
  dist[source] = 0
  pq = [(0, source)]
  while pq:
    dist_u, u  = h.heappop(pq)
    for v, weight in graph[u]:
      if dist[v] == -1 or dist_u + weight < dist[v]:
        dist[v] = dist_u + weight
        h.heappush(pq, (dist[v], v))
  return dist

def req_node(graph, source, target):
  alice_dist = dijkstra(graph, source)
  bob_dist = dijkstra(graph, target)
  time_min = float('inf')
  meet_node = -1

  for i in range(1, len(graph)+1):
    if alice_dist[i] != -1 and bob_dist[i] != -1:
      total_time = max(alice_dist[i], bob_dist[i])
      if total_time < time_min:
        time_min = total_time
        meet_node = i
  if time_min == float('inf'):
    return "Impossible"
  else:
    return time_min, meet_node

source_node, target_node = map(int, input_file.readline().split())

result = req_node(graph, source_node, target_node)
if result == "Impossible":
  output_file.write("Impossible")
else:
  time, node = result
  output_file.write(f"Time {time}\nNode {node}")

#Task 3

input_file = open("input3_2.txt" , "r")
output_file = open("output3_2.txt" , "w")

nodes, edges = map(int, input_file.readline().strip().split())
graph = {i:[] for i in range(1, nodes + 1)}

for i in range(edges):
  u, v, weight = map(int, input_file.readline().strip().split())
  graph[u].append((v, weight))
weights = []

def safe_path(graph, start, end, w = []):
  for i in graph[start]:
    w.append(i[1])
    if i[0] != end:
      safe_path(graph, i[0], end, w)
    else:
      weights.append(max(w))
    w.pop(len(w) - 1)
safe_path(graph, 1, nodes)

if weights!=[]:
  output_file.write(str(min(weights)))
else:
  output_file.write('Impossible')

input_file.close()
output_file.close()